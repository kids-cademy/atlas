package com.kidscademy.atlas.util;

import java.lang.ref.WeakReference;

import js.lang.Callback;
import js.log.Log;
import js.log.LogFactory;

/**
 * Asynchronous tasks that may return a value. User defined logic to be executed asynchronously should be implemented on
 * {@link #execute()} method. AsyncTask also supplies hooks for pre- and post- execution and for error handling, see
 * {@link #onPreExecute()}, {@link #onPostExecute(Object)} and {@link #onThrowable(Throwable)}.
 * <p>
 * There are two ways to execute an asynchronous tasks: with or without callback. In both cases user code should supply
 * implementation for {@link #execute()}. When execute without callback user code should also implement
 * {@link #onPostExecute(Object)} which by default is NOP, see sample code below.
 *
 * <pre>
 * 		AsyncTask&lt;Calendar&gt; task = new AsyncTask&lt;Calendar&gt;() {
 * 			protected Calendar execute() throws Throwable {
 * 				. . .
 * 				return calendar;
 *            }
 *
 * 			protected void onPostExecute(Calendar calendar) {
 * 				. . .
 *            }
 *        };
 * 		task.start();
 * </pre>
 * <p>
 * When give callback on asynchronous task construction its {@link Callback#handle(Object)} method is invoked when
 * background processing is complete. Callback hook is not invoked if execute conclude in error. Also if user defined
 * code overrides {@link #onPostExecute(Object)} callback is not invoked. This usage pattern is useful when user code
 * already has a callback instance that just pass it to asynchronous task constructor.
 *
 * <pre>
 * 		AsyncTask&lt;Calendar&gt; task = new AsyncTask&lt;Calendar&gt;(callback) {
 * 			protected Calendar execute() throws Throwable {
 * 				. . .
 * 				return calendar;
 *            }
 *        };
 * 		task.start();
 * </pre>
 *
 * @author Iulian Rotaru
 */
public abstract class AsyncTask<Result> {
    /**
     * Class logger.
     */
    private static final Log log = LogFactory.getLog(AsyncTask.class);

    /**
     * User defined logic to be executed asynchronously.
     *
     * @return logic execution result.
     * @throws Throwable if anything goes wrong.
     */
    abstract protected Result execute() throws Throwable;

    /**
     * Optional callback, default to null.
     */
    private Callback<Result> callback;

    /**
     * Flag true if {@link #execute()} conclude in error. If error on execute do not invoke {@link #onPostExecute(Object)}
     * .
     */
    private boolean errorOnExecute;

    private android.os.AsyncTask<Void, Void, Result> asyncTask;

    /**
     * Create asynchronous task without callback.
     */
    protected AsyncTask() {
    }

    /**
     * Create asynchronous task with callback.
     *
     * @param callback callback instance.
     */
    protected AsyncTask(Callback<Result> callback) {
        this.callback = callback;
    }

    /**
     * Start asyncrhonous logic execution.
     */
    public void start() {
        asyncTask = new AsyncTaskImpl<>(this);
        asyncTask.execute();
    }

    public void cancel() {
        asyncTask.cancel(true);
    }

    public boolean isCancelled() {
        return asyncTask.isCancelled();
    }

    /**
     * Hook invoked just before {@link #execute()}, default to NOP.
     */
    protected void onPreExecute() {
    }

    /**
     * Executed after asynchronous logic execution completes. Result value is that returned by {@link #execute()} method.
     * If asynchronous logic ends in error this hook is not invoked. By default this hook invoke {@link #callback}, if
     * defined.
     *
     * @param result asynchronous logic computation result.
     */
    protected void onPostExecute(Result result) {
        if (this.callback != null) {
            this.callback.handle(result);
        }
    }

    /**
     * Error handler by default just write error to logger.
     *
     * @param throwable throwable generated by asynchronous execution logic.
     */
    protected void onThrowable(Throwable throwable) {
        log.error(throwable);
    }

    private static class AsyncTaskImpl<Params, Progress, Result> extends android.os.AsyncTask<Params, Progress, Result> {

        private AsyncTask<Result> reference;

        AsyncTaskImpl(AsyncTask<Result> reference) {
            this.reference = reference;
        }

        @Override
        protected void onPreExecute() {
            reference.onPreExecute();
        }

        @Override
        protected Result doInBackground(Params[] params) {
            try {
                return reference.execute();
            } catch (Throwable throwable) {
                reference.errorOnExecute = true;
                reference.onThrowable(throwable);
            }
            return null;
        }

        @Override
        protected void onPostExecute(Result result) {
            // takes care to not invoke post execute hook if there are errors on execute
            if (!reference.errorOnExecute) {
                reference.onPostExecute(result);
            }
            reference = null;
        }
    }
}
